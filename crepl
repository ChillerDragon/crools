#!/bin/bash

# a creppy C lang repl
# REPL as in READ EVALUATE PRINT LOOP
# trying to to mimic pythons interactive shell or rubys irb
# for the C programming language

dbg() {
	[[ "$DEBUG" != "" ]] || return

	printf '[DEBUG] %s\n' "$1"
}

mkdir -p /tmp/crools-"$USER"/crepl/

tmp_src_file="$(mktemp /tmp/crools-"$USER"/crepl/entry_XXXXXXXXXXXXX.c)" # entry file for compliation
tmp_src_file_test_includes="$(mktemp /tmp/crools-"$USER"/crepl/test_includes_XXXXXXXXXXXXX.c)" # do not add includes that do not compile
tmp_src_file_includes="$(mktemp /tmp/crools-"$USER"/crepl/includes_XXXXXXXXXXXXX.c)" # #includes added by user on top
tmp_src_file_main="$(mktemp /tmp/crools-"$USER"/crepl/main_XXXXXXXXXXXXX.c)" # main func body
tmp_src_file_test_main="$(mktemp /tmp/crools-"$USER"/crepl/test_main_XXXXXXXXXXXXX.c)" # test if it compiles before persisting
tmp_src_file_functions="$(mktemp /tmp/crools-"$USER"/crepl/functions_XXXXXXXXXXXXX.c)" # define function above main
tmp_src_file_test_functions="$(mktemp /tmp/crools-"$USER"/crepl/test_functions_XXXXXXXXXXXXX.c)" # test if func compiles before persisiting
tmp_src_file_tmp="$(mktemp /tmp/crools-"$USER"/crepl/tmp_XXXXXXXXXXXXX.c)" # run only once never persist (if eval is a print for example)
tmp_src_file_out="$(mktemp /tmp/crools-"$USER"/crepl/bin_XXXXXXXXXXXXX.c)" # output binary

chmod +x "$tmp_src_file_out"

:>"$tmp_src_file"
cat << EOF > "$tmp_src_file"
#include <stdio.h>
#include <stdlib.h>

#include "$tmp_src_file_includes"
#include "$tmp_src_file_test_includes"

#include "$tmp_src_file_functions"
#include "$tmp_src_file_test_functions"

int main()
{
	#include "$tmp_src_file_main"
	#include "$tmp_src_file_test_main"
	#include "$tmp_src_file_tmp"
}
EOF

cleanup() {
	echo "exit(0)"
	rm "$tmp_src_file"
	rm "$tmp_src_file_test_includes"
	rm "$tmp_src_file_includes"
	rm "$tmp_src_file_main"
	rm "$tmp_src_file_test_main"
	rm "$tmp_src_file_test_functions"
	rm "$tmp_src_file_functions"
	rm "$tmp_src_file_tmp"
	rm "$tmp_src_file_out"
}

trap cleanup EXIT

compiler() {
	g++ "$@"
}

crepl_build() {
	if compiler "$tmp_src_file" -o "$tmp_src_file_out" -I"$PWD"
	then
		cat "$tmp_src_file_test_main" >> "$tmp_src_file_main"
		cat "$tmp_src_file_test_functions" >> "$tmp_src_file_functions"
		cat "$tmp_src_file_test_includes" >> "$tmp_src_file_includes"
	fi
}

crepl_run() {
	"$tmp_src_file_out"
}

c_var_pattern='[a-zA-Z_][a-zA-Z_0-9]*'
c_func_name_pattern="$c_var_pattern"
c_stmt_pattern='[^;]+' # TODO: do this better ; can be part of a for loop and of a string for example

# TODO: func pattern doesnt match
c_type_pattern='(void|int|char|long|long long|float|double|short|int64_t|time_t)'
c_single_line_func_pattern='(const\ *)?'"$c_type_pattern"'\ *\*?\ *'"$c_var_pattern"'\ *\(.*\)\ *{.*}'

tab_complete() {
	# p<tab> works but this is ugly use compgen to generate that stuff
	[[ ${#READLINE_LINE} -eq 0 ]] && READLINE_LINE=$(fc -l -n -1 | xargs)
	if [ "$READLINE_LINE" == "p" ]
	then
		READLINE_LINE="printf("
		READLINE_POINT="${#READLINE_LINE}"
	fi
}

mkdir -p ~/.config/crools

history -r ~/.config/crools/crepl_history
set -o emacs

# shellcheck disable=SC2128
if [ "${BASH_VERSINFO}" -ge 4 ]
then
	bind -x '"\t":"tab_complete"'
else
	echo "Warning: your bash is too old for autocompletion"
fi

parse_args() {
	while true
	do
		[[ "$#" -gt "0" ]] || break

		arg="$1"
		shift

		if [ "$arg" == "-h" ]
		then
			echo "usage: crepl [OPTION..]"
			echo "options:"
			echo "  --cplay <filename>     quickstart with cplay file"
			exit 0
		elif [ "$arg" == "--cplay" ]
		then
			local filename
			filename="$1"
			shift
			if [ "$filename" == "" ]
			then
				echo "usage: crepl --cplay <filename>"
				exit 1
			fi
			cplay_include="#include \"/tmp/crools-$USER/cplay/$filename\""
			echo "> $cplay_include"
			printf '%s\n' "$cplay_include" > "$tmp_src_file_test_includes"
			crepl_build
			crepl_run

			:>"$tmp_src_file_test_includes"
		fi
	done
}

parse_args "$@"

is_int_func_call() {
	local input="$1"
	if ! [[ "$input" =~ ^\ *(${c_func_name_pattern})\((${c_stmt_pattern})\)\;+$ ]]
	then
		return 1
	fi
	local func_name
	local func_arg
	if ! func_name="${BASH_REMATCH[1]}"
	then
		return 1
	fi
	[[ "$func_name" = "" ]] && return 1
	func_arg="${BASH_REMATCH[2]}"
	if ! man -P cat "$func_name" 2>/dev/null | grep -q "int $func_name("
	then
		return 1
	fi
	dbg "got single method call to '$func_name' which returns int"
	dbg "func arg=$func_arg"
	# print int return value to stdout
	printf '%s\n' "$input" > "$tmp_src_file_test_main"
	printf 'printf("=> %%d\\n", %s);\n' "$func_name($func_arg)" > "$tmp_src_file_tmp"
	return 0
}

while IFS= read -e -r -p "> " input
do
	history -s "$input"
	if [[ "$input" =~ ^[:space:]*(puts|printf)\( ]]
	then
		printf '%s\n' "$input" > "$tmp_src_file_tmp"
	elif [[ "$input" =~ ^\ *int\ +${c_var_pattern}\ *=(${c_stmt_pattern})\;+$ ]]
	then
		# print int assignment result to stdout
		printf '%s\n' "$input" > "$tmp_src_file_test_main"
		printf 'printf("=> %%d\\n", %s);\n' "${BASH_REMATCH[1]}" > "$tmp_src_file_tmp"
	elif is_int_func_call "$input"
	then
		test # handled in is_int_func_call()
	elif [[ "$input" =~ $c_single_line_func_pattern ]]
	then
		printf '%s\n' "$input" > "$tmp_src_file_test_functions"
	elif [[ "$input" =~ ^#include(\ |\"|<) ]]
	then
		# use space/tab in front of #include in the repl
		# to not add it at the top of the program
		# but inside of main
		printf '%s\n' "$input" > "$tmp_src_file_test_includes"
	else
		printf '%s\n' "$input" > "$tmp_src_file_test_main"
	fi
	crepl_build
	crepl_run

	:>"$tmp_src_file_test_includes"
	:>"$tmp_src_file_test_main"
	:>"$tmp_src_file_tmp"
done

history -w ~/.config/crools/crepl_history

